;; -*- lexical-binding: t; -*-

(defun uni-numerical-diff (f h)
  "Numerical differentiation where F is the univariate function and H is the tiny change in the input\nMake sure to use floating point inputs"
  (lambda (x)
    (/ (- (funcall f (+ x h)) (funcall f x)) h)))

(funcall (uni-numerical-diff (lambda (x) (* x x)) 0.0001) 1)

(defun numerical-diff (f h &rest xs)
  "Numerical differentiation where F is a multivariate function, H is the tiny change in the inputs, and XS contains the input values\nMake sure to use floating point inputs"
  (let ((grad '()))
    (dotimes (i (length xs))
      ;; (message "%s" grad)
      (setq grad (append grad (list (/ (- (apply f (append (take i xs)
						   (list (+ (nth i xs) h))
						   (drop (+ i 1) xs)))
					  (apply f xs))
				       h)))))
    grad))

(numerical-diff (lambda (w x y z) (+ (* x x) (* 3 y) (/ w 2) (exp z))) 0.001 1.0 4.0 2.0 1.0)
(numerical-diff (lambda (x y) (* x y)) 0.001 1 2)

;; Forward-mode Autodiff Using Dual Numbers a + bε -> [a, b]
;; Rules: ε ≠ 0 and ε² = 0

(defun Const (n)
  "Take in a N real number and return its dual number (itself plus a zero ε component)"
  `[,n 0])

(defun Add (x y)
  "Add two dual numbers (a + bε and c + dε) [a + c, b + d]"
  `[,(+ (aref x 0) (aref y 0)) ,(+ (aref x 1) (aref y 1))])

(defun Minus (x y)
  "Subtract two dual numbers (a + bε and c + dε) [a - c, b - d]"
  `[,(- (aref x 0) (aref y 0)) ,(- (aref x 1) (aref y 1))])
  
(defun Times (x y)
  "Multiply two dual numbers (a + bε and c + dε) [ac, (ad + bc)]"
  `[,(* (aref x 0) (aref y 0)) ,(+ (* (aref x 0) (aref y 1)) (* (aref x 1) (aref y 0)))])

(defun Exponent (x n)
  "Raise dual number a + bε to the nth power"
  `[,(expt (aref x 0) n) ,(* n (expt (aref x 0) (1- n)) (aref x 1))])

(defun fdiff (f &rest xs)
  "Forward-mode autodiff that uses dual numbers to calculate gradient"
  (let ((grad '()))
    (dotimes (i (length xs))
      (setq grad (append grad (list (apply f (append (mapcar (lambda (c) `[,c 0]) (take i xs))
						     (list `[,(nth i xs) 1])
						     (mapcar (lambda (c) `[,c 0]) (drop (1+ i) xs))))))))
    (mapcar (lambda (dual) (aref dual 1)) grad)))

(defun MyFun (x y)
  "Dual number function xy + 3x + 5"
  (Add (Add (Times x y) (Times (Const 3) x)) (Const 5)))

(fdiff 'MyFun 3 2)

(fdiff (lambda (w x y) (Add (Exponent (Minus (Times w x) y) 2) (Exponent w 2))) 24 2 41)

;; Reverse Mode Autodiff
(setq my-graph
      '(("inp" 0)
	("inp" 1)
	("inp" 2)
	("mul" (0 1))
	("sub" (3 2))
	("expt" (4) 2)
	("expt" (0) 2)
	("add" (5 6))))

(defun forward (function &rest xs)
  (let ((dag '())
	(inputs (mapcar 'float xs)))
    (dolist (node function)
      (cond ((equal (car node) "inp") (setq dag (append dag (list (nth (nth 1 node) inputs)))))
	    ((equal (car node) "add") (setq dag (append dag (list (+ (apply '+ (mapcar (lambda (x) (nth x dag)) (nth 1 node)))
								     (or (nth 2 node)
									 0))))))
	    ((equal (car node) "sub") (setq dag (append dag (list (apply '- (append (mapcar (lambda (x) (nth x dag)) (nth 1 node)) (list (or (nth 2 node) 0))))))))
	    ((equal (car node) "mul") (setq dag (append dag (list (* (apply '* (mapcar (lambda (x) (nth x dag)) (nth 1 node)))
								     (or (nth 2 node)
									 1))))))
	    ((equal (car node) "div") (setq dag (append dag (list (apply '/ (mapcar (lambda (x) (nth x dag)) (nth 1 node)))))))
	    ((equal (car node) "expt") (setq dag (append dag (list (expt (nth (car (nth 1 node)) dag) (nth 2 node))))))
	    ((equal (car node) "dot") (setq dag (append dag (list (apply '+ (seq-mapn '* (mapcar (lambda (x) (nth x dag)) (nth 1 node)) (nth 2 node)))))))
	    ((equal (car node) "smax") (let* ((vals (mapcar (lambda (x) (nth x dag)) (nth 1 node)))
					      (normed-vals (mapcar (lambda (x) (- x (seq-max vals))) vals)))
					 (setq dag (append dag (list (/ (exp (- (nth (nth 2 node) dag) (seq-max vals))) (apply '+ (mapcar 'exp normed-vals))))))))
	    ((equal (car node) "xent") (setq dag (append dag (list (- (apply '+ (seq-mapn '* (mapcar (lambda (x) (log (+ (nth x dag) 0.1))) (nth 1 node)) (nth 2 node))))))))))
    dag))

(forward my-graph 24 2 41)


(setq my-graph-2
      '(("inp" 0)
	("inp" 1)
	("inp" 2)
	("mul" (0 1))
	("mul" (1 2))
	("add" (3 4))))

(forward my-graph-2 1 2 3) ;; (1 2 3 2 6 8)
(reverse my-graph-2)

(defun backward (graph dag)
  (let ((grad (make-list (length graph) '()))
	(inputs 0))
    (dotimes (i (length graph))
      (cond ((equal (car (nth i graph)) "inp") (setq inputs (1+ inputs)))
	    ((equal (car (nth i graph)) "add") (setq grad (seq-map-indexed (lambda (elem ind)
									     (if (member ind (nth 1 (nth i graph)))
										 (append (or (nth (- (length graph) (1+ i)) grad)
											     '(1))
											 elem)
									       elem))
									   grad)))
	    ((equal (car (nth i graph)) "sub") (setq grad (seq-map-indexed (lambda (elem ind)
									     (cond ((equal ind (nth 0 (nth 1 (nth i graph))))
										    (append (or (nth (- (length graph) (1+ i)) grad)
												'(1))
											    elem))
										   ((equal ind (nth 1 (nth 1 (nth i graph))))
										    (cons (- (or (car (nth (- (length graph) (1+ i)) grad))
											      1))
											  elem))
										   (t elem)))
									   grad)))									
	    ((equal (car (nth i graph)) "mul") (setq grad (seq-map-indexed (lambda (elem ind)
									     (cond ((equal ind (nth 0 (nth 1 (nth i graph))))
										    (cons (* (or (nth 2 (nth i graph))
												 (nth (nth 1 (nth 1 (nth i graph))) dag))
											     (or (car (nth (- (length graph) (1+ i)) grad))
												 1))
											  elem))
										   ((equal ind (nth 1 (nth 1 (nth i graph))))
										    (cons (* (nth (nth 0 (nth 1 (nth i graph))) dag)
											      (or (car (nth (- (length graph) (1+ i)) grad))
												  1))
											      elem))
										   (t elem)))
									   grad)))
	    ((equal (car (nth i graph)) "expt") (setq grad (seq-map-indexed (lambda (elem ind)
									       (if (equal ind (car (nth 1 (nth i graph))))
										   (cons (* (nth 2 (nth i graph))
											    (expt (nth ind dag) (1- (nth 2 (nth i graph))))
											    (or (car (nth (- (length graph) (1+ i)) grad))
												1))
											 elem)
										 elem))
									     grad)))))
      ;; (message "%s" grad))
    (take inputs (mapcar (lambda (x) (seq-reduce '+ x 0)) grad))))

(setq test-graph
      '(("inp" 0)
	("inp" 1)
	("mul" (0 1))
	("add" (0 2))))

(forward test-graph 2 3)

(setq my-graph-3
      '(("inp" 0)
	("inp" 1)
	("inp" 2)
	("add" (0 1))
	("add" (1 2))
	("mul" (3 4))))

(setq my-graph-4
      '(("inp" 0)
	("inp" 1)
	("mul" (0) 2)
	("mul" (1) 3)
	("add" (2 3))
	("mul" (0 4))))

(setq test-graph-2
      '(("inp" 0)
	("inp" 1)
	("mul" (0 1))
	("sub" (0 2))))

(setq test-graph-3
      '(("inp" 0)
	("inp" 1)
	("expt" (0) 3)
	("sub" (2 1))))


(backward (reverse test-graph) (forward test-graph 4 10)) ;; x + xy
(backward (reverse my-graph-2) (forward my-graph-2 1 2 3)) ;; xy + yz
(backward (reverse my-graph-3) (forward my-graph-3 1 2 3)) ;; (x + y) * (y + z)
(backward (reverse my-graph-4) (forward my-graph-4 4 1)) ;; x * (2x + 3y) -> (4x + 3y, 3x)
(backward (reverse test-graph-2) (forward test-graph-2 2 4)) ;; 1 - y
(backward (reverse test-graph-3) (forward test-graph-3 2 2)) ;; x^3 - y
(backward (reverse my-graph) (forward my-graph 1 2 3))

(defun rdiff (function &rest xs)
  "Reverse-mode autodiff with forward pass loop and then a backward pass with corresponding pullback functions for a computational graph representation of a function as input"
  (let ((dag '())
	(inputs (mapcar 'float xs)))
    (dolist (node function)
      (cond ((equal (car node) "inp") (setq dag (append dag (list (nth (nth 1 node) inputs)))))
	    ((equal (car node) "add") (setq dag (append dag (list (+ (apply '+ (mapcar (lambda (x) (nth x dag)) (nth 1 node)))
								     (or (nth 2 node)
									 0))))))
	    ((equal (car node) "sub") (setq dag (append dag (list (apply '- (append (mapcar (lambda (x) (nth x dag)) (nth 1 node)) (list (or (nth 2 node) 0))))))))
	    ((equal (car node) "mul") (setq dag (append dag (list (* (apply '* (mapcar (lambda (x) (nth x dag)) (nth 1 node)))
								     (or (nth 2 node)
									 1))))))
	    ((equal (car node) "div") (setq dag (append dag (list (apply '/ (mapcar (lambda (x) (nth x dag)) (nth 1 node)))))))
	    ((equal (car node) "expt") (setq dag (append dag (list (expt (nth (car (nth 1 node)) dag) (nth 2 node))))))
	    ((equal (car node) "dot") (setq dag (append dag (list (apply '+ (seq-mapn '* (mapcar (lambda (x) (nth x dag)) (nth 1 node)) (nth 2 node)))))))
	    ((equal (car node) "smax") (let* ((vals (mapcar (lambda (x) (nth x dag)) (nth 1 node)))
					      (normed-vals (mapcar (lambda (x) (- x (seq-max vals))) vals)))
					 (setq dag (append dag (list (/ (exp (- (nth (nth 2 node) dag) (seq-max vals))) (apply '+ (mapcar 'exp normed-vals))))))))
	    ((equal (car node) "xent") (setq dag (append dag (list (- (apply '+ (seq-mapn '* (mapcar (lambda (x) (log (+ (nth x dag) 0.1))) (nth 1 node)) (nth 2 node))))))))))
    (let ((grad (make-list (length function) '()))
	  (graph (reverse function)))
      (dotimes (i (- (length graph) (length inputs)))
	(cond ((equal (car (nth i graph)) "add") (setq grad (seq-map-indexed (lambda (elem ind)
									       (if (member ind (nth 1 (nth i graph)))
										   (append (or (nth i (reverse grad))
											       '(1))
											   elem)
										 elem))
									     grad)))
	      ((equal (car (nth i graph)) "sub") (setq grad (seq-map-indexed (lambda (elem ind)
									       (cond ((equal ind (nth 0 (nth 1 (nth i graph))))
										      (cons (or (car (nth i (reverse grad)))
												1)
											    elem))
										     ((equal ind (nth 1 (nth 1 (nth i graph))))
										      (cons (- (or (car (nth i (reverse grad)))
												   1))
											    elem))
										     (t elem)))
									     grad)))									
	      ((equal (car (nth i graph)) "mul") (setq grad (seq-map-indexed (lambda (elem ind)
									       (cond ((equal ind (nth 0 (nth 1 (nth i graph))))
										      (cons (* (or (nth 2 (nth i graph))
												   (nth (nth 1 (nth 1 (nth i graph))) dag))
											       (or (car (nth i (reverse grad)))
												   1))
											    elem))
										     ((equal ind (nth 1 (nth 1 (nth i graph))))
										      (cons (* (nth (nth 0 (nth 1 (nth i graph))) dag)
											       (or (car (nth i (reverse grad)))
												   1))
											    elem))
										     (t elem)))
									     grad)))
	      ((equal (car (nth i graph)) "div") (setq grad (seq-map-indexed (lambda (elem ind)
									       (cond ((equal ind (nth 0 (nth 1 (nth i graph))))
										      (cons (* (/ 1.0 (or (nth 2 (nth i graph))
													  (nth (nth 1 (nth 1 (nth i graph))) dag)))
											       (or (car (nth i (reverse grad)))
												   1))
											    elem))
										     ((equal ind (nth 1 (nth 1 (nth i graph))))
										      (cons (* (nth (nth 0 (nth 1 (nth i graph))) dag)
											       (- (/ 1.0 (expt (nth ind dag) 2)))
											       (or (car (nth i (reverse grad)))
												   1))
											    elem))
										     (t elem)))
									     grad)))
	      ((equal (car (nth i graph)) "expt") (setq grad (seq-map-indexed (lambda (elem ind)
										(if (equal ind (car (nth 1 (nth i graph))))
										    (cons (* (nth 2 (nth i graph))
											     (expt (nth ind dag) (1- (nth 2 (nth i graph))))
											     (or (car (nth i (reverse grad)))
												 1))
											  elem)
										  elem))
									      grad)))
	      ((equal (car (nth i graph)) "dot") (setq grad (seq-map-indexed (lambda (elem ind)
									       (if (member ind (nth 1 (nth i graph)))
										   (cons (* (nth (seq-position (nth 1 (nth i graph)) ind) (nth 2 (nth i graph)))
											    (or (car (nth i (reverse grad)))
												1))
											 elem)
										 elem))
									     grad)))
	      ((equal (car (nth i graph)) "smax") (setq grad (seq-map-indexed (lambda (elem ind)
										(cond ((equal ind (nth 2 (nth i graph)))
										       (cons (* (nth i (reverse dag))
												(- 1 (nth i (reverse dag)))
												(or (car (nth i (reverse grad)))
												    1))
											     elem))
										      ((member ind (nth 1 (nth i graph)))
										       (cons (* (nth i (reverse dag))
												(nth (+ i (- ind (nth 2 (nth i graph)))) (reverse dag))
												(or (car (nth i (reverse grad)))
												    1))
											     elem))
										      (t elem)))
									      grad)))
	      ((equal (car (nth i graph)) "xent") (setq grad (seq-map-indexed (lambda (elem ind)
										(if (member ind (nth 1 (nth i graph)))
										    (cons (- (* (/ 1.0 (+ (nth ind dag) 0.1))
												(nth (seq-position (nth 1 (nth i graph)) ind) (nth 2 (nth i graph)))
												(or (nth i (reverse grad))
												    1)))
											  elem)
										  elem))
									      grad)))))
      (take (length inputs) (mapcar (lambda (x) (seq-reduce '+ x 0)) grad)))))

(rdiff '(("inp" 0) ("inp" 1) ("inp" 2) ("mul" (0 1)) ("sub" (2) 3) ("add" (3 4)) ("expt" (5) 3) ("div" (6 1))) 1 2 3)

(rdiff '(("inp" 0) ("inp" 1) ("inp" 2) ("dot" (0 1 2) (242 2 52.05))) 1 2 3)

(rdiff '(("inp" 0) ("inp" 1) ("inp" 2) ("smax" (0 1 2) 0) ("smax" (0 1 2) 1) ("smax" (0 1 2) 2) ("xent" (3 4 5) (1 0 0))) 1 2 3)

